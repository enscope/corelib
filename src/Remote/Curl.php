<?php

    namespace Corelib\Remote
    {
	    use Corelib\Core\DisposableInterface;
	    use Corelib\Core\Using;

	    /**
	     * Class Curl
	     *
	     * Simple object-oriented cURL wrapper.
	     *
	     * @package Corelib\Remote
	     *
	     * Following methods are auto-generated by __call() magic:
	     *
	     * @method string  getUrl()
	     * @method void    setUrl(string $url)
	     * @method string  getMethod()
	     * @method void    setMethod(string $method)
	     * @method boolean getHeader()
	     * @method void    setHeader(boolean $header)
	     * @method boolean getFollowLocation()
	     * @method void    setFollowLocation(boolean $header)
	     * @method mixed   getPostFields()
	     * @method void    setPostFields(string $post_fields)
	     * @method boolean getReturnTransfer()
	     * @method void    setReturnTransfer(string $return_transfer)
	     * @method int     getTimeout()
	     * @method void    setTimeout(int $timeout)
	     * @method int     getTimeoutMillis()
	     * @method void    setTimeoutMillis(int $timeout_millis)
	     * @method int     getConnectionTimeout()
	     * @method void    setConnectionTimeout(int $timeout)
	     * @method int     getConnectionTimeoutMillis()
	     * @method void    setConnectionTimeoutMillis(int $timeout_millis)
	     *
	     * Following static methods can be used to perform requests:
	     *
         * @method static mixed OPTIONS(string $url, array $curl_opts = null)
	     * @method static mixed GET(string $url, array $curl_opts = null)
	     * @method static mixed HEAD(string $url, array $curl_opts = null)
	     * @method static mixed POST(string $url, string $data = null, array $curl_opts = null)
	     * @method static mixed PUT(string $url, string $data = null, array $curl_opts = null)
	     * @method static mixed DELETE(string $url, array $curl_opts = null)
	     * @method static mixed TRACE(string $url, array $curl_opts = null)
	     */
	    class Curl
        implements DisposableInterface
        {
		    //region --- Private members ---

		    private static $defaults = [
			    CURLOPT_CUSTOMREQUEST => self::METHOD_GET,
			    CURLOPT_RETURNTRANSFER => true,
			    CURLOPT_CONNECTTIMEOUT => 30,
			    CURLOPT_TIMEOUT => 30
		    ];

		    private static $optionAccessors = [
			    'Url' => CURLOPT_URL,
			    'Method' => CURLOPT_CUSTOMREQUEST,
			    'Header' => CURLOPT_HEADER,
			    'FollowLocation' => CURLOPT_FOLLOWLOCATION,
			    'PostFields' => CURLOPT_POSTFIELDS,
			    'ReturnTransfer' => CURLOPT_RETURNTRANSFER,
			    'Timeout' => CURLOPT_TIMEOUT,
			    'TimeoutMillis' => CURLOPT_TIMEOUT_MS,
			    'ConnectionTimeout' => CURLOPT_CONNECTTIMEOUT,
			    'ConnectionTimeoutMillis' => CURLOPT_CONNECTTIMEOUT_MS
		    ];

	        private $curl;
		    private $options;

		    //endregion

		    //region --- Constants ---

		    const METHOD_OPTIONS = 'OPTIONS';
		    const METHOD_GET = 'GET';
		    const METHOD_HEAD = 'HEAD';
		    const METHOD_POST = 'POST';
		    const METHOD_PUT = 'PUT';
		    const METHOD_DELETE = 'DELETE';
		    const METHOD_TRACE = 'TRACE';

		    //endregion

	        public function __construct($url = null, $method = self::METHOD_GET)
	        {
		        $this->curl = curl_init();
		        $this->options = self::$defaults;
		        curl_setopt_array($this->curl, self::$defaults);
		        if (is_string($url))
		        {
			        $this->setUrl($url);
		        }
		        $this->setMethod($method);
	        }

		    //region --- Magic functions ---

		    public function __call($name, $args)
		    {
			    $className = get_class();
			    $countArgs = count($args);

			    switch (@substr($name, 0, 3))
			    {
				    case 'get':
						$option = substr($name, 3);
						if (array_key_exists($option, self::$optionAccessors))
						{
							return ($this->getOption(self::$optionAccessors[$option]));
						}
				        break;

				    case 'set':
					    $option = substr($name, 3);
					    if (array_key_exists($option, self::$optionAccessors))
					    {
						    if ($countArgs < 1)
						    {
							    trigger_error("$className::$name() expects at least 1 parameter, $countArgs given", E_USER_WARNING);
							    return (null);
						    }
						    return ($this->setOption(self::$optionAccessors[$option], $args[0]));
					    }
					    break;
			    }

			    trigger_error("Call to undefined method $className::$name()", E_USER_ERROR);
		    }

		    public static function __callStatic($name, $args)
		    {
			    $className = get_class();
			    $countArgs = count($args);

			    $methodConstName = __CLASS__ . '::' . strtoupper('METHOD_' . $name);
			    if (defined($methodConstName))
			    {
				    // it is valid method constant, therefore assume,
				    // it is a method call, check arguments and call request
				    if ($countArgs < 1)
				    {
					    trigger_error("$className::$name() expects at least 1 parameter, $countArgs given", E_USER_WARNING);
					    return (null);
				    }
				    // prepare function arguments (URL, METHOD)
				    $funcArgs = [
					    'url' => $args[0],
					    'method' => constant($methodConstName)
				    ];
				    if (($countArgs >= 2)
				        && ($countArgs <= 3))
				    {
					    foreach (array_slice($args, 1) as $param)
					    {
						    $funcArgs[is_array($param) ? 'opts' : 'data'] = $param;
					    }
				    }

				    return (call_user_func([__CLASS__, '_request'], $funcArgs));
			    }

			    trigger_error("Call to undefined method $className::$name()", E_USER_ERROR);
		    }

		    //endregion

		    //region --- Destructor & Disposable implementation ---

		    public function __destruct()
		    {
			    $this->_dispose(false);
		    }

		    public function dispose()
		    {
			    $this->_dispose(true);
		    }

		    protected function _dispose($disposing)
		    {
			    if ($disposing)
			    {
				    if ($this->curl != null)
				    {
					    curl_close($this->curl);
				    }
			    }
		    }

		    //endregion

		    //region --- cURL option accessors ---

		    public function setOption($option, $value)
		    {
			    $this->options[$option] = $value;
			    return (curl_setopt($this->curl, $option, $value));
		    }

		    public function getOption($option)
		    {
			    return (@$this->options[$option]);
		    }

		    public function setOptions($options, $replace = false)
		    {
			    if ($replace)
			    {
				    // will perform complete reset of curl handle
				    // and then inject given options
				    curl_init($this->curl);
				    $this->options = $options;
			    }
			    else
			    {
				    // will only merge options
				    array_merge($this->options, $options);
			    }
			    return (curl_setopt_array($this->curl, $options));
		    }

		    //endregion

		    //region --- Request execution methods ---

		    /**
		     * @param bool $infer_type      Method will infer type from Content-type header
		     *                              and tries to decode the value and return structure
		     *                              instead of body string
		     * @param bool $throw_on_error  Throws exception on cURL error
		     *
		     * @return bool|mixed|string    Response as string (body) or mixed (inferred)
		     */
		    public function execute($infer_type = true, $throw_on_error = false)
		    {
			    if (!($response = $this->executeResponse($throw_on_error)))
			    {
				    return (false);
			    }

			    if ($infer_type)
			    {
				    switch (explode(';', $response->getHeader('content-type'))[0])
				    {
					    case 'application/json':
						    return (json_decode($response->getBody()));
				    }
			    }
			    return ($response->getBody());
		    }

		    protected function _execute($return_transfer = true, $throw_on_error = false)
		    {
			    $this->setReturnTransfer($return_transfer);
			    if (($result = curl_exec($this->curl)) === false)
			    {
				    if ($throw_on_error)
				    {
					    throw new CurlException(curl_error($this->curl));
				    }
			    }
			    return ($result);
		    }

		    /**
		     * @param bool $throw_on_error
		     *
		     * @returns CurlResponse
		     * @throws CurlException
		     */
		    public function executeResponse($throw_on_error = false)
		    {
			    $this->setHeader(true);
			    return (new CurlResponse(
				    $this->_execute(true, $throw_on_error),
				    curl_getinfo($this->curl, CURLINFO_HEADER_SIZE)
			    ));
		    }

		    //endregion

		    //region --- Static helpers ---

		    public static function request($url, $method = self::METHOD_GET, $data = null, $opts = null)
		    {
			    return (self::_request([
				    'url' => $url,
				    'method' => $method,
				    'data' => $data,
				    'opts' => $opts
			    ]));
		    }

		    protected static function _request($args)
		    {
			    return (Using::_(new Curl($args['url'], $args['method']),
				    function(Curl $curl) use ($args)
				    {
					    if (!empty($args['opts'])
					        && is_array($args['opts']))
					    {
						    $curl->setOptions($args['opts']);
					    }
					    if (!empty($args['data'])
					        && is_string($args['data']))
					    {
						    $curl->setPostFields($args['data']);
					    }
					    return ($curl->execute());
				    }));
		    }

		    //endregion

		    //region --- Defaults handling ---

		    public static function setDefaults($defaults)
		    {
			    self::$defaults = $defaults;
		    }

		    public static function getDefaults()
		    {
			    return (self::$defaults);
		    }

		    public static function setDefaultOption($option, $value)
		    {
			    self::$defaults[$option] = $value;
		    }

		    public static function getDefaultOption($option)
		    {
			    return (@self::$defaults[$option]);
		    }

		    //endregion
        }
    }